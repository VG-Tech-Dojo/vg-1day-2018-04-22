package bot

import (
	"regexp"
	"strings"

	"fmt"

	"encoding/json"
	"github.com/VG-Tech-Dojo/vg-1day-2018-04-22/yuta/env"
	"github.com/VG-Tech-Dojo/vg-1day-2018-04-22/yuta/model"
	"io/ioutil"
	"net/http"
	"net/url"
	"time"
	"os"
	"bytes"
	"encoding/base64"
)

const (
	keywordAPIURLFormat = "https://jlp.yahooapis.jp/KeyphraseService/V1/extract?appid=%s&sentence=%s&output=json"
)

type (
	// Processor はmessageを受け取り、投稿用messageを作るインターフェースです
	Processor interface {
		Process(message *model.Message) (*model.Message, error)
	}

	// HelloWorldProcessor は"hello, world!"メッセージを作るprocessorの構造体です
	HelloWorldProcessor struct{}

	// OmikujiProcessor は"大吉", "吉", "中吉", "小吉", "末吉", "凶"のいずれかをランダムで作るprocessorの構造体です
	OmikujiProcessor struct{}

	// KeywordProcessor はメッセージ本文からキーワードを抽出するprocessorの構造体です
	KeywordProcessor struct{}

	GachaProcessor struct{}

	ChatProcessor struct{}

	ClarifaiProcessor struct{}
)

// Process は"hello, world!"というbodyがセットされたメッセージのポインタを返します
func (p *HelloWorldProcessor) Process(msgIn *model.Message) (*model.Message, error) {
	return &model.Message{
		Body: msgIn.Body + ", world!",
	}, nil
}

// Process は"大吉", "吉", "中吉", "小吉", "末吉", "凶"のいずれかがbodyにセットされたメッセージへのポインタを返します
func (p *OmikujiProcessor) Process(msgIn *model.Message) (*model.Message, error) {
	fortunes := []string{
		"大吉",
		"吉",
		"中吉",
		"小吉",
		"末吉",
		"凶",
	}
	result := fortunes[randIntn(len(fortunes))]
	return &model.Message{
		Body: result,
	}, nil
}

// Process はメッセージ本文からキーワードを抽出します
func (p *KeywordProcessor) Process(msgIn *model.Message) (*model.Message, error) {
	r := regexp.MustCompile("\\Akeyword (.*)\\z")
	matchedStrings := r.FindStringSubmatch(msgIn.Body)
	text := matchedStrings[1]

	url := fmt.Sprintf(keywordAPIURLFormat, env.KeywordAPIAppID, url.QueryEscape(text))

	type keywordAPIResponse map[string]interface{}
	var json keywordAPIResponse
	get(url, &json)

	keywords := []string{}
	for k, v := range json {
		if k == "Error" {
			return nil, fmt.Errorf("%#v", v)
		}
		keywords = append(keywords, k)
	}

	return &model.Message{
		Body: "キーワード：" + strings.Join(keywords, ", "),
	}, nil
}

func (p *GachaProcessor) Process(msgIn *model.Message) (*model.Message, error) {
	rare := []string{
		"SSレア",
		"Sレア",
		"レア",
		"ノーマル",
	}
	result := rare[randIntn(len(rare))]
	return &model.Message{
		Body: result,
	}, nil
}

type TalkResponse struct {
	Status  int    `json:"status"`
	Message string `json:"message"`
	Results []struct {
		Perplexity float64 `json:"perplexity"`
		Reply      string  `json:"reply"`
	} `json:"results"`
}

func (p *ChatProcessor) Process(msgIn *model.Message) (*model.Message, error) {
	r := regexp.MustCompile("\\Atalk (.*)\\z")
	matchedStrings := r.FindStringSubmatch(msgIn.Body)
	text := matchedStrings[1]

	values := url.Values{}
	values.Add("apikey", env.ChatAPIAppID)
	values.Add("query", text)

	resp, err := http.PostForm("https://api.a3rt.recruit-tech.co.jp/talk/v1/smalltalk", values)
	if err != nil {
		return nil, err
	}

	body, _ := ioutil.ReadAll(resp.Body)
	defer resp.Body.Close()

	var talkResponse TalkResponse
	err = json.Unmarshal(body, &talkResponse)
	if err != nil {
		return nil, err
	}

	return &model.Message{
		Body: talkResponse.Results[0].Reply,
	}, nil
}

type Clarifai struct {
	Status struct {
		Code        int    `json:"code"`
		Description string `json:"description"`
	} `json:"status"`
	Outputs []struct {
		ID string `json:"id"`
		Status struct {
			Code        int    `json:"code"`
			Description string `json:"description"`
		} `json:"status"`
		CreatedAt time.Time `json:"created_at"`
		Model struct {
			ID        string    `json:"id"`
			Name      string    `json:"name"`
			CreatedAt time.Time `json:"created_at"`
			AppID     string    `json:"app_id"`
			OutputInfo struct {
				Message string `json:"message"`
				Type    string `json:"type"`
				TypeExt string `json:"type_ext"`
			} `json:"output_info"`
			ModelVersion struct {
				ID        string    `json:"id"`
				CreatedAt time.Time `json:"created_at"`
				Status struct {
					Code        int    `json:"code"`
					Description string `json:"description"`
				} `json:"status"`
			} `json:"model_version"`
			DisplayName string `json:"display_name"`
		} `json:"model"`
		Input struct {
			ID string `json:"id"`
			Data struct {
				Image struct {
					URL string `json:"url"`
				} `json:"image"`
			} `json:"data"`
		} `json:"input"`
		Data struct {
			Concepts []struct {
				ID    string  `json:"id"`
				Name  string  `json:"name"`
				Value float64 `json:"value"`
				AppID string  `json:"app_id"`
			} `json:"concepts"`
		} `json:"data"`
	} `json:"outputs"`
}

type ImageMessage struct {
	Image string   `json:"image"`
	Tags  []string `json:"tags"`
}

func (p *ClarifaiProcessor) Process(path string) (*model.Message, error) {

	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go

	//type Payload struct {
	//	Inputs []struct {
	//		Data struct {
	//			Image struct {
	//				Base64 string `json:"base64"`
	//			} `json:"image"`
	//		} `json:"data"`
	//	} `json:"inputs"`
	//}

	f, err := os.Open(path)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	b, _ := ioutil.ReadAll(f)
	base := base64.StdEncoding.EncodeToString(b)

	payloadBytes := []byte(`{
    "inputs": [
      {
        "data": {
          "image": {
            "base64": "` + base + `"
          }
        }
      }
    ]
  }`)
	//requestBody := bytes.NewBuffer(payloadBytes)
	//data := Payload{
	//	// fill struct
	//}
	//payloadBytes, err := json.Marshal(data)
	//if err != nil {
	//	// handle err
	//}
	body := bytes.NewReader(payloadBytes)

	req, err := http.NewRequest("POST", "https://api.clarifai.com/v2/models/aaa03c23b3724a16a56b629203edc62c/outputs", body)
	if err != nil {
		// handle err
	}
	req.Header.Set("Authorization", "Key "+env.ClarifaiAppID)
	req.Header.Set("Content-Type", "application/json")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		// handle err
	}
	defer resp.Body.Close()

	//f, err := os.Open(path)
	//if err != nil {
	//	return nil, err
	//}
	//defer f.Close()
	//req, err := http.NewRequest("POST", "https://api.clarifai.com/v2/models/aaa03c23b3724a16a56b629203edc62c/outputs", f)
	//if err != nil {
	//	// handle err
	//}
	//req.Header.Set("Authorization", "Key "+env.ClarifaiAppID)
	//req.Header.Set("Content-Type", "application/json")
	//
	//resp, err := http.DefaultClient.Do(req)
	//if err != nil {
	//	// handle err
	//}
	//defer resp.Body.Close()

	responseBody, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var clarifai Clarifai
	if err := json.Unmarshal(responseBody, &clarifai); err != nil {
		return nil, err
	}

	var tags []string
	for _, concept := range clarifai.Outputs[0].Data.Concepts {
		tags = append(tags, concept.Name)
	}

	imageMessage := ImageMessage{Image: path, Tags: tags}
	jsonBytes, err := json.Marshal(imageMessage)
	if err != nil {
		return nil, err
	}

	return &model.Message{
		Body: string(jsonBytes),
	}, nil
}
